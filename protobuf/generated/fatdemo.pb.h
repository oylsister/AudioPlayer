// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: fatdemo.proto
// Protobuf C++ Version: 6.30.0-rc1

#ifndef fatdemo_2eproto_2epb_2eh
#define fatdemo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6030000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "networkbasetypes.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_fatdemo_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_fatdemo_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_fatdemo_2eproto;
}  // extern "C"
enum EHitGroup : int;
extern const uint32_t EHitGroup_internal_data_[];
enum ETeam : int;
extern const uint32_t ETeam_internal_data_[];
enum EWeaponType : int;
extern const uint32_t EWeaponType_internal_data_[];
class MLDemoHeader;
struct MLDemoHeaderDefaultTypeInternal;
extern MLDemoHeaderDefaultTypeInternal _MLDemoHeader_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLDemoHeader_class_data_;
class MLDict;
struct MLDictDefaultTypeInternal;
extern MLDictDefaultTypeInternal _MLDict_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLDict_class_data_;
class MLEvent;
struct MLEventDefaultTypeInternal;
extern MLEventDefaultTypeInternal _MLEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLEvent_class_data_;
class MLGameState;
struct MLGameStateDefaultTypeInternal;
extern MLGameStateDefaultTypeInternal _MLGameState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLGameState_class_data_;
class MLMatchState;
struct MLMatchStateDefaultTypeInternal;
extern MLMatchStateDefaultTypeInternal _MLMatchState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLMatchState_class_data_;
class MLPlayerState;
struct MLPlayerStateDefaultTypeInternal;
extern MLPlayerStateDefaultTypeInternal _MLPlayerState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLPlayerState_class_data_;
class MLRoundState;
struct MLRoundStateDefaultTypeInternal;
extern MLRoundStateDefaultTypeInternal _MLRoundState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLRoundState_class_data_;
class MLTick;
struct MLTickDefaultTypeInternal;
extern MLTickDefaultTypeInternal _MLTick_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLTick_class_data_;
class MLWeaponState;
struct MLWeaponStateDefaultTypeInternal;
extern MLWeaponStateDefaultTypeInternal _MLWeaponState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MLWeaponState_class_data_;
class VacNetShot;
struct VacNetShotDefaultTypeInternal;
extern VacNetShotDefaultTypeInternal _VacNetShot_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull VacNetShot_class_data_;
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::EHitGroup_internal_data_>
    internal::EnumTraitsImpl::value<::EHitGroup>;
template <>
internal::EnumTraitsT<::ETeam_internal_data_>
    internal::EnumTraitsImpl::value<::ETeam>;
template <>
internal::EnumTraitsT<::EWeaponType_internal_data_>
    internal::EnumTraitsImpl::value<::EWeaponType>;
}  // namespace protobuf
}  // namespace google

enum EHitGroup : int {
  EHG_Generic = 0,
  EHG_Head = 1,
  EHG_Chest = 2,
  EHG_Stomach = 3,
  EHG_LeftArm = 4,
  EHG_RightArm = 5,
  EHG_LeftLeg = 6,
  EHG_RightLeg = 7,
  EHG_Gear = 8,
  EHG_Miss = 9,
};

extern const uint32_t EHitGroup_internal_data_[];
inline constexpr EHitGroup EHitGroup_MIN =
    static_cast<EHitGroup>(0);
inline constexpr EHitGroup EHitGroup_MAX =
    static_cast<EHitGroup>(9);
inline bool EHitGroup_IsValid(int value) {
  return 0 <= value && value <= 9;
}
inline constexpr int EHitGroup_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EHitGroup_descriptor();
template <typename T>
const std::string& EHitGroup_Name(T value) {
  static_assert(std::is_same<T, EHitGroup>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EHitGroup_Name().");
  return EHitGroup_Name(static_cast<EHitGroup>(value));
}
template <>
inline const std::string& EHitGroup_Name(EHitGroup value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EHitGroup_descriptor, 0, 9>(
      static_cast<int>(value));
}
inline bool EHitGroup_Parse(
    absl::string_view name, EHitGroup* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EHitGroup>(EHitGroup_descriptor(), name,
                                           value);
}
enum ETeam : int {
  ET_Unknown = 0,
  ET_Spectator = 1,
  ET_Terrorist = 2,
  ET_CT = 3,
};

extern const uint32_t ETeam_internal_data_[];
inline constexpr ETeam ETeam_MIN =
    static_cast<ETeam>(0);
inline constexpr ETeam ETeam_MAX =
    static_cast<ETeam>(3);
inline bool ETeam_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int ETeam_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ETeam_descriptor();
template <typename T>
const std::string& ETeam_Name(T value) {
  static_assert(std::is_same<T, ETeam>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ETeam_Name().");
  return ETeam_Name(static_cast<ETeam>(value));
}
template <>
inline const std::string& ETeam_Name(ETeam value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ETeam_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool ETeam_Parse(
    absl::string_view name, ETeam* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETeam>(ETeam_descriptor(), name,
                                           value);
}
enum EWeaponType : int {
  EWT_Knife = 0,
  EWT_Pistol = 1,
  EWT_SubMachineGun = 2,
  EWT_Rifle = 3,
  EWT_Shotgun = 4,
  EWT_SniperRifle = 5,
  EWT_MachineGun = 6,
  EWT_C4 = 7,
  EWT_Grenade = 8,
  EWT_Equipment = 9,
  EWT_StackableItem = 10,
  EWT_Unknown = 11,
};

extern const uint32_t EWeaponType_internal_data_[];
inline constexpr EWeaponType EWeaponType_MIN =
    static_cast<EWeaponType>(0);
inline constexpr EWeaponType EWeaponType_MAX =
    static_cast<EWeaponType>(11);
inline bool EWeaponType_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int EWeaponType_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EWeaponType_descriptor();
template <typename T>
const std::string& EWeaponType_Name(T value) {
  static_assert(std::is_same<T, EWeaponType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EWeaponType_Name().");
  return EWeaponType_Name(static_cast<EWeaponType>(value));
}
template <>
inline const std::string& EWeaponType_Name(EWeaponType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EWeaponType_descriptor, 0, 11>(
      static_cast<int>(value));
}
inline bool EWeaponType_Parse(
    absl::string_view name, EWeaponType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EWeaponType>(EWeaponType_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class VacNetShot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:VacNetShot) */ {
 public:
  inline VacNetShot() : VacNetShot(nullptr) {}
  ~VacNetShot() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VacNetShot* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VacNetShot));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VacNetShot(::google::protobuf::internal::ConstantInitialized);

  inline VacNetShot(const VacNetShot& from) : VacNetShot(nullptr, from) {}
  inline VacNetShot(VacNetShot&& from) noexcept
      : VacNetShot(nullptr, std::move(from)) {}
  inline VacNetShot& operator=(const VacNetShot& from) {
    CopyFrom(from);
    return *this;
  }
  inline VacNetShot& operator=(VacNetShot&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VacNetShot& default_instance() {
    return *reinterpret_cast<const VacNetShot*>(
        &_VacNetShot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(VacNetShot& a, VacNetShot& b) { a.Swap(&b); }
  inline void Swap(VacNetShot* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VacNetShot* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VacNetShot* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VacNetShot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VacNetShot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VacNetShot& from) { VacNetShot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VacNetShot* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "VacNetShot"; }

 protected:
  explicit VacNetShot(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  VacNetShot(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const VacNetShot& from);
  VacNetShot(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, VacNetShot&& from) noexcept
      : VacNetShot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDeltaYawWindowFieldNumber = 6,
    kDeltaPitchWindowFieldNumber = 7,
    kSteamidPlayerFieldNumber = 1,
    kRoundNumberFieldNumber = 2,
    kHitTypeFieldNumber = 3,
    kWeaponTypeFieldNumber = 4,
    kDistanceToHurtTargetFieldNumber = 5,
  };
  // repeated float delta_yaw_window = 6;
  int delta_yaw_window_size() const;
  private:
  int _internal_delta_yaw_window_size() const;

  public:
  void clear_delta_yaw_window() ;
  float delta_yaw_window(int index) const;
  void set_delta_yaw_window(int index, float value);
  void add_delta_yaw_window(float value);
  const ::google::protobuf::RepeatedField<float>& delta_yaw_window() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_delta_yaw_window();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_delta_yaw_window() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_delta_yaw_window();

  public:
  // repeated float delta_pitch_window = 7;
  int delta_pitch_window_size() const;
  private:
  int _internal_delta_pitch_window_size() const;

  public:
  void clear_delta_pitch_window() ;
  float delta_pitch_window(int index) const;
  void set_delta_pitch_window(int index, float value);
  void add_delta_pitch_window(float value);
  const ::google::protobuf::RepeatedField<float>& delta_pitch_window() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL mutable_delta_pitch_window();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_delta_pitch_window() const;
  ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL _internal_mutable_delta_pitch_window();

  public:
  // optional fixed64 steamid_player = 1;
  bool has_steamid_player() const;
  void clear_steamid_player() ;
  ::uint64_t steamid_player() const;
  void set_steamid_player(::uint64_t value);

  private:
  ::uint64_t _internal_steamid_player() const;
  void _internal_set_steamid_player(::uint64_t value);

  public:
  // optional int32 round_number = 2;
  bool has_round_number() const;
  void clear_round_number() ;
  ::int32_t round_number() const;
  void set_round_number(::int32_t value);

  private:
  ::int32_t _internal_round_number() const;
  void _internal_set_round_number(::int32_t value);

  public:
  // optional int32 hit_type = 3;
  bool has_hit_type() const;
  void clear_hit_type() ;
  ::int32_t hit_type() const;
  void set_hit_type(::int32_t value);

  private:
  ::int32_t _internal_hit_type() const;
  void _internal_set_hit_type(::int32_t value);

  public:
  // optional int32 weapon_type = 4;
  bool has_weapon_type() const;
  void clear_weapon_type() ;
  ::int32_t weapon_type() const;
  void set_weapon_type(::int32_t value);

  private:
  ::int32_t _internal_weapon_type() const;
  void _internal_set_weapon_type(::int32_t value);

  public:
  // optional float distance_to_hurt_target = 5;
  bool has_distance_to_hurt_target() const;
  void clear_distance_to_hurt_target() ;
  float distance_to_hurt_target() const;
  void set_distance_to_hurt_target(float value);

  private:
  float _internal_distance_to_hurt_target() const;
  void _internal_set_distance_to_hurt_target(float value);

  public:
  // @@protoc_insertion_point(class_scope:VacNetShot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const VacNetShot& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> delta_yaw_window_;
    ::google::protobuf::RepeatedField<float> delta_pitch_window_;
    ::uint64_t steamid_player_;
    ::int32_t round_number_;
    ::int32_t hit_type_;
    ::int32_t weapon_type_;
    float distance_to_hurt_target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull VacNetShot_class_data_;
// -------------------------------------------------------------------

class MLWeaponState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLWeaponState) */ {
 public:
  inline MLWeaponState() : MLWeaponState(nullptr) {}
  ~MLWeaponState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLWeaponState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLWeaponState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLWeaponState(::google::protobuf::internal::ConstantInitialized);

  inline MLWeaponState(const MLWeaponState& from) : MLWeaponState(nullptr, from) {}
  inline MLWeaponState(MLWeaponState&& from) noexcept
      : MLWeaponState(nullptr, std::move(from)) {}
  inline MLWeaponState& operator=(const MLWeaponState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLWeaponState& operator=(MLWeaponState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLWeaponState& default_instance() {
    return *reinterpret_cast<const MLWeaponState*>(
        &_MLWeaponState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(MLWeaponState& a, MLWeaponState& b) { a.Swap(&b); }
  inline void Swap(MLWeaponState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLWeaponState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLWeaponState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLWeaponState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLWeaponState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLWeaponState& from) { MLWeaponState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLWeaponState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLWeaponState"; }

 protected:
  explicit MLWeaponState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLWeaponState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLWeaponState& from);
  MLWeaponState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLWeaponState&& from) noexcept
      : MLWeaponState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kStateFieldNumber = 7,
    kIndexFieldNumber = 1,
    kTypeFieldNumber = 3,
    kAmmoClipFieldNumber = 4,
    kAmmoClipMaxFieldNumber = 5,
    kAmmoReserveFieldNumber = 6,
    kRecoilIndexFieldNumber = 8,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional string state = 7;
  bool has_state() const;
  void clear_state() ;
  const std::string& state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_state(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_state();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_state();
  void set_allocated_state(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_state() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // optional int32 index = 1;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // optional .EWeaponType type = 3 [default = EWT_Knife];
  bool has_type() const;
  void clear_type() ;
  ::EWeaponType type() const;
  void set_type(::EWeaponType value);

  private:
  ::EWeaponType _internal_type() const;
  void _internal_set_type(::EWeaponType value);

  public:
  // optional int32 ammo_clip = 4;
  bool has_ammo_clip() const;
  void clear_ammo_clip() ;
  ::int32_t ammo_clip() const;
  void set_ammo_clip(::int32_t value);

  private:
  ::int32_t _internal_ammo_clip() const;
  void _internal_set_ammo_clip(::int32_t value);

  public:
  // optional int32 ammo_clip_max = 5;
  bool has_ammo_clip_max() const;
  void clear_ammo_clip_max() ;
  ::int32_t ammo_clip_max() const;
  void set_ammo_clip_max(::int32_t value);

  private:
  ::int32_t _internal_ammo_clip_max() const;
  void _internal_set_ammo_clip_max(::int32_t value);

  public:
  // optional int32 ammo_reserve = 6;
  bool has_ammo_reserve() const;
  void clear_ammo_reserve() ;
  ::int32_t ammo_reserve() const;
  void set_ammo_reserve(::int32_t value);

  private:
  ::int32_t _internal_ammo_reserve() const;
  void _internal_set_ammo_reserve(::int32_t value);

  public:
  // optional float recoil_index = 8;
  bool has_recoil_index() const;
  void clear_recoil_index() ;
  float recoil_index() const;
  void set_recoil_index(float value);

  private:
  float _internal_recoil_index() const;
  void _internal_set_recoil_index(float value);

  public:
  // @@protoc_insertion_point(class_scope:MLWeaponState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   1, 39,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLWeaponState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr state_;
    ::int32_t index_;
    int type_;
    ::int32_t ammo_clip_;
    ::int32_t ammo_clip_max_;
    ::int32_t ammo_reserve_;
    float recoil_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLWeaponState_class_data_;
// -------------------------------------------------------------------

class MLRoundState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLRoundState) */ {
 public:
  inline MLRoundState() : MLRoundState(nullptr) {}
  ~MLRoundState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLRoundState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLRoundState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLRoundState(::google::protobuf::internal::ConstantInitialized);

  inline MLRoundState(const MLRoundState& from) : MLRoundState(nullptr, from) {}
  inline MLRoundState(MLRoundState&& from) noexcept
      : MLRoundState(nullptr, std::move(from)) {}
  inline MLRoundState& operator=(const MLRoundState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLRoundState& operator=(MLRoundState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLRoundState& default_instance() {
    return *reinterpret_cast<const MLRoundState*>(
        &_MLRoundState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(MLRoundState& a, MLRoundState& b) { a.Swap(&b); }
  inline void Swap(MLRoundState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLRoundState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLRoundState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLRoundState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLRoundState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLRoundState& from) { MLRoundState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLRoundState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLRoundState"; }

 protected:
  explicit MLRoundState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLRoundState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLRoundState& from);
  MLRoundState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLRoundState&& from) noexcept
      : MLRoundState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPhaseFieldNumber = 1,
    kBombStateFieldNumber = 3,
    kWinTeamFieldNumber = 2,
  };
  // optional string phase = 1;
  bool has_phase() const;
  void clear_phase() ;
  const std::string& phase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phase(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_phase();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_phase();
  void set_allocated_phase(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_phase() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_phase(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_phase();

  public:
  // optional string bomb_state = 3;
  bool has_bomb_state() const;
  void clear_bomb_state() ;
  const std::string& bomb_state() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bomb_state(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_bomb_state();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_bomb_state();
  void set_allocated_bomb_state(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_bomb_state() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bomb_state(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_bomb_state();

  public:
  // optional .ETeam win_team = 2 [default = ET_Unknown];
  bool has_win_team() const;
  void clear_win_team() ;
  ::ETeam win_team() const;
  void set_win_team(::ETeam value);

  private:
  ::ETeam _internal_win_team() const;
  void _internal_set_win_team(::ETeam value);

  public:
  // @@protoc_insertion_point(class_scope:MLRoundState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 36,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLRoundState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phase_;
    ::google::protobuf::internal::ArenaStringPtr bomb_state_;
    int win_team_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLRoundState_class_data_;
// -------------------------------------------------------------------

class MLMatchState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLMatchState) */ {
 public:
  inline MLMatchState() : MLMatchState(nullptr) {}
  ~MLMatchState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLMatchState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLMatchState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLMatchState(::google::protobuf::internal::ConstantInitialized);

  inline MLMatchState(const MLMatchState& from) : MLMatchState(nullptr, from) {}
  inline MLMatchState(MLMatchState&& from) noexcept
      : MLMatchState(nullptr, std::move(from)) {}
  inline MLMatchState& operator=(const MLMatchState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLMatchState& operator=(MLMatchState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLMatchState& default_instance() {
    return *reinterpret_cast<const MLMatchState*>(
        &_MLMatchState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(MLMatchState& a, MLMatchState& b) { a.Swap(&b); }
  inline void Swap(MLMatchState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLMatchState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLMatchState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLMatchState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLMatchState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLMatchState& from) { MLMatchState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLMatchState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLMatchState"; }

 protected:
  explicit MLMatchState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLMatchState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLMatchState& from);
  MLMatchState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLMatchState&& from) noexcept
      : MLMatchState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGameModeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kRoundFieldNumber = 3,
    kScoreCtFieldNumber = 4,
    kScoreTFieldNumber = 5,
  };
  // optional string game_mode = 1;
  bool has_game_mode() const;
  void clear_game_mode() ;
  const std::string& game_mode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_game_mode(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_game_mode();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_game_mode();
  void set_allocated_game_mode(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_game_mode() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_game_mode(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_game_mode();

  public:
  // optional string phase = 2;
  bool has_phase() const;
  void clear_phase() ;
  const std::string& phase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phase(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_phase();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_phase();
  void set_allocated_phase(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_phase() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_phase(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_phase();

  public:
  // optional int32 round = 3;
  bool has_round() const;
  void clear_round() ;
  ::int32_t round() const;
  void set_round(::int32_t value);

  private:
  ::int32_t _internal_round() const;
  void _internal_set_round(::int32_t value);

  public:
  // optional int32 score_ct = 4;
  bool has_score_ct() const;
  void clear_score_ct() ;
  ::int32_t score_ct() const;
  void set_score_ct(::int32_t value);

  private:
  ::int32_t _internal_score_ct() const;
  void _internal_set_score_ct(::int32_t value);

  public:
  // optional int32 score_t = 5;
  bool has_score_t() const;
  void clear_score_t() ;
  ::int32_t score_t() const;
  void set_score_t(::int32_t value);

  private:
  ::int32_t _internal_score_t() const;
  void _internal_set_score_t(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLMatchState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLMatchState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr game_mode_;
    ::google::protobuf::internal::ArenaStringPtr phase_;
    ::int32_t round_;
    ::int32_t score_ct_;
    ::int32_t score_t_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLMatchState_class_data_;
// -------------------------------------------------------------------

class MLDict final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLDict) */ {
 public:
  inline MLDict() : MLDict(nullptr) {}
  ~MLDict() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLDict* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLDict));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLDict(::google::protobuf::internal::ConstantInitialized);

  inline MLDict(const MLDict& from) : MLDict(nullptr, from) {}
  inline MLDict(MLDict&& from) noexcept
      : MLDict(nullptr, std::move(from)) {}
  inline MLDict& operator=(const MLDict& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDict& operator=(MLDict&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDict& default_instance() {
    return *reinterpret_cast<const MLDict*>(
        &_MLDict_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(MLDict& a, MLDict& b) { a.Swap(&b); }
  inline void Swap(MLDict* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDict* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDict* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLDict>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLDict& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLDict& from) { MLDict::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLDict* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLDict"; }

 protected:
  explicit MLDict(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLDict(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLDict& from);
  MLDict(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLDict&& from) noexcept
      : MLDict(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 1,
    kValStringFieldNumber = 2,
    kValIntFieldNumber = 3,
    kValFloatFieldNumber = 4,
  };
  // optional string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // optional string val_string = 2;
  bool has_val_string() const;
  void clear_val_string() ;
  const std::string& val_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_val_string(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_val_string();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_val_string();
  void set_allocated_val_string(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_val_string() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_val_string(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_val_string();

  public:
  // optional int32 val_int = 3;
  bool has_val_int() const;
  void clear_val_int() ;
  ::int32_t val_int() const;
  void set_val_int(::int32_t value);

  private:
  ::int32_t _internal_val_int() const;
  void _internal_set_val_int(::int32_t value);

  public:
  // optional float val_float = 4;
  bool has_val_float() const;
  void clear_val_float() ;
  float val_float() const;
  void set_val_float(float value);

  private:
  float _internal_val_float() const;
  void _internal_set_val_float(float value);

  public:
  // @@protoc_insertion_point(class_scope:MLDict)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 28,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLDict& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr val_string_;
    ::int32_t val_int_;
    float val_float_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLDict_class_data_;
// -------------------------------------------------------------------

class MLDemoHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLDemoHeader) */ {
 public:
  inline MLDemoHeader() : MLDemoHeader(nullptr) {}
  ~MLDemoHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLDemoHeader* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLDemoHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLDemoHeader(::google::protobuf::internal::ConstantInitialized);

  inline MLDemoHeader(const MLDemoHeader& from) : MLDemoHeader(nullptr, from) {}
  inline MLDemoHeader(MLDemoHeader&& from) noexcept
      : MLDemoHeader(nullptr, std::move(from)) {}
  inline MLDemoHeader& operator=(const MLDemoHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLDemoHeader& operator=(MLDemoHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLDemoHeader& default_instance() {
    return *reinterpret_cast<const MLDemoHeader*>(
        &_MLDemoHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(MLDemoHeader& a, MLDemoHeader& b) { a.Swap(&b); }
  inline void Swap(MLDemoHeader* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLDemoHeader* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLDemoHeader* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLDemoHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLDemoHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLDemoHeader& from) { MLDemoHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLDemoHeader* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLDemoHeader"; }

 protected:
  explicit MLDemoHeader(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLDemoHeader(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLDemoHeader& from);
  MLDemoHeader(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLDemoHeader&& from) noexcept
      : MLDemoHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapNameFieldNumber = 1,
    kTickRateFieldNumber = 2,
    kVersionFieldNumber = 3,
    kSteamUniverseFieldNumber = 4,
  };
  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name() ;
  const std::string& map_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_map_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_map_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_map_name();
  void set_allocated_map_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_map_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_map_name();

  public:
  // optional int32 tick_rate = 2;
  bool has_tick_rate() const;
  void clear_tick_rate() ;
  ::int32_t tick_rate() const;
  void set_tick_rate(::int32_t value);

  private:
  ::int32_t _internal_tick_rate() const;
  void _internal_set_tick_rate(::int32_t value);

  public:
  // optional uint32 version = 3;
  bool has_version() const;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // optional uint32 steam_universe = 4;
  bool has_steam_universe() const;
  void clear_steam_universe() ;
  ::uint32_t steam_universe() const;
  void set_steam_universe(::uint32_t value);

  private:
  ::uint32_t _internal_steam_universe() const;
  void _internal_set_steam_universe(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLDemoHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 29,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLDemoHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr map_name_;
    ::int32_t tick_rate_;
    ::uint32_t version_;
    ::uint32_t steam_universe_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLDemoHeader_class_data_;
// -------------------------------------------------------------------

class MLPlayerState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLPlayerState) */ {
 public:
  inline MLPlayerState() : MLPlayerState(nullptr) {}
  ~MLPlayerState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLPlayerState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLPlayerState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLPlayerState(::google::protobuf::internal::ConstantInitialized);

  inline MLPlayerState(const MLPlayerState& from) : MLPlayerState(nullptr, from) {}
  inline MLPlayerState(MLPlayerState&& from) noexcept
      : MLPlayerState(nullptr, std::move(from)) {}
  inline MLPlayerState& operator=(const MLPlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLPlayerState& operator=(MLPlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLPlayerState& default_instance() {
    return *reinterpret_cast<const MLPlayerState*>(
        &_MLPlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(MLPlayerState& a, MLPlayerState& b) { a.Swap(&b); }
  inline void Swap(MLPlayerState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLPlayerState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLPlayerState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLPlayerState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLPlayerState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLPlayerState& from) { MLPlayerState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLPlayerState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLPlayerState"; }

 protected:
  explicit MLPlayerState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLPlayerState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLPlayerState& from);
  MLPlayerState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLPlayerState&& from) noexcept
      : MLPlayerState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWeaponsFieldNumber = 20,
    kNameFieldNumber = 4,
    kClanFieldNumber = 5,
    kAbsposFieldNumber = 7,
    kEyeangleFieldNumber = 8,
    kEyeangleFwdFieldNumber = 9,
    kAccountIdFieldNumber = 1,
    kEntindexFieldNumber = 3,
    kTeamFieldNumber = 6,
    kHealthFieldNumber = 10,
    kArmorFieldNumber = 11,
    kFlashedFieldNumber = 12,
    kSmokedFieldNumber = 13,
    kMoneyFieldNumber = 14,
    kRoundKillsFieldNumber = 15,
    kRoundKillhsFieldNumber = 16,
    kBurningFieldNumber = 17,
    kHelmetFieldNumber = 18,
    kDefuseKitFieldNumber = 19,
    kPlayerSlotFieldNumber = 2,
  };
  // repeated .MLWeaponState weapons = 20;
  int weapons_size() const;
  private:
  int _internal_weapons_size() const;

  public:
  void clear_weapons() ;
  ::MLWeaponState* PROTOBUF_NONNULL mutable_weapons(int index);
  ::google::protobuf::RepeatedPtrField<::MLWeaponState>* PROTOBUF_NONNULL mutable_weapons();

  private:
  const ::google::protobuf::RepeatedPtrField<::MLWeaponState>& _internal_weapons() const;
  ::google::protobuf::RepeatedPtrField<::MLWeaponState>* PROTOBUF_NONNULL _internal_mutable_weapons();
  public:
  const ::MLWeaponState& weapons(int index) const;
  ::MLWeaponState* PROTOBUF_NONNULL add_weapons();
  const ::google::protobuf::RepeatedPtrField<::MLWeaponState>& weapons() const;
  // optional string name = 4;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // optional string clan = 5;
  bool has_clan() const;
  void clear_clan() ;
  const std::string& clan() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clan(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_clan();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_clan();
  void set_allocated_clan(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_clan() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_clan(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_clan();

  public:
  // optional .CMsgVector abspos = 7;
  bool has_abspos() const;
  void clear_abspos() ;
  const ::CMsgVector& abspos() const;
  [[nodiscard]] ::CMsgVector* PROTOBUF_NULLABLE release_abspos();
  ::CMsgVector* PROTOBUF_NONNULL mutable_abspos();
  void set_allocated_abspos(::CMsgVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_abspos(::CMsgVector* PROTOBUF_NULLABLE value);
  ::CMsgVector* PROTOBUF_NULLABLE unsafe_arena_release_abspos();

  private:
  const ::CMsgVector& _internal_abspos() const;
  ::CMsgVector* PROTOBUF_NONNULL _internal_mutable_abspos();

  public:
  // optional .CMsgQAngle eyeangle = 8;
  bool has_eyeangle() const;
  void clear_eyeangle() ;
  const ::CMsgQAngle& eyeangle() const;
  [[nodiscard]] ::CMsgQAngle* PROTOBUF_NULLABLE release_eyeangle();
  ::CMsgQAngle* PROTOBUF_NONNULL mutable_eyeangle();
  void set_allocated_eyeangle(::CMsgQAngle* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eyeangle(::CMsgQAngle* PROTOBUF_NULLABLE value);
  ::CMsgQAngle* PROTOBUF_NULLABLE unsafe_arena_release_eyeangle();

  private:
  const ::CMsgQAngle& _internal_eyeangle() const;
  ::CMsgQAngle* PROTOBUF_NONNULL _internal_mutable_eyeangle();

  public:
  // optional .CMsgVector eyeangle_fwd = 9;
  bool has_eyeangle_fwd() const;
  void clear_eyeangle_fwd() ;
  const ::CMsgVector& eyeangle_fwd() const;
  [[nodiscard]] ::CMsgVector* PROTOBUF_NULLABLE release_eyeangle_fwd();
  ::CMsgVector* PROTOBUF_NONNULL mutable_eyeangle_fwd();
  void set_allocated_eyeangle_fwd(::CMsgVector* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_eyeangle_fwd(::CMsgVector* PROTOBUF_NULLABLE value);
  ::CMsgVector* PROTOBUF_NULLABLE unsafe_arena_release_eyeangle_fwd();

  private:
  const ::CMsgVector& _internal_eyeangle_fwd() const;
  ::CMsgVector* PROTOBUF_NONNULL _internal_mutable_eyeangle_fwd();

  public:
  // optional int32 account_id = 1;
  bool has_account_id() const;
  void clear_account_id() ;
  ::int32_t account_id() const;
  void set_account_id(::int32_t value);

  private:
  ::int32_t _internal_account_id() const;
  void _internal_set_account_id(::int32_t value);

  public:
  // optional int32 entindex = 3;
  bool has_entindex() const;
  void clear_entindex() ;
  ::int32_t entindex() const;
  void set_entindex(::int32_t value);

  private:
  ::int32_t _internal_entindex() const;
  void _internal_set_entindex(::int32_t value);

  public:
  // optional .ETeam team = 6 [default = ET_Unknown];
  bool has_team() const;
  void clear_team() ;
  ::ETeam team() const;
  void set_team(::ETeam value);

  private:
  ::ETeam _internal_team() const;
  void _internal_set_team(::ETeam value);

  public:
  // optional int32 health = 10;
  bool has_health() const;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // optional int32 armor = 11;
  bool has_armor() const;
  void clear_armor() ;
  ::int32_t armor() const;
  void set_armor(::int32_t value);

  private:
  ::int32_t _internal_armor() const;
  void _internal_set_armor(::int32_t value);

  public:
  // optional float flashed = 12;
  bool has_flashed() const;
  void clear_flashed() ;
  float flashed() const;
  void set_flashed(float value);

  private:
  float _internal_flashed() const;
  void _internal_set_flashed(float value);

  public:
  // optional float smoked = 13;
  bool has_smoked() const;
  void clear_smoked() ;
  float smoked() const;
  void set_smoked(float value);

  private:
  float _internal_smoked() const;
  void _internal_set_smoked(float value);

  public:
  // optional int32 money = 14;
  bool has_money() const;
  void clear_money() ;
  ::int32_t money() const;
  void set_money(::int32_t value);

  private:
  ::int32_t _internal_money() const;
  void _internal_set_money(::int32_t value);

  public:
  // optional int32 round_kills = 15;
  bool has_round_kills() const;
  void clear_round_kills() ;
  ::int32_t round_kills() const;
  void set_round_kills(::int32_t value);

  private:
  ::int32_t _internal_round_kills() const;
  void _internal_set_round_kills(::int32_t value);

  public:
  // optional int32 round_killhs = 16;
  bool has_round_killhs() const;
  void clear_round_killhs() ;
  ::int32_t round_killhs() const;
  void set_round_killhs(::int32_t value);

  private:
  ::int32_t _internal_round_killhs() const;
  void _internal_set_round_killhs(::int32_t value);

  public:
  // optional float burning = 17;
  bool has_burning() const;
  void clear_burning() ;
  float burning() const;
  void set_burning(float value);

  private:
  float _internal_burning() const;
  void _internal_set_burning(float value);

  public:
  // optional bool helmet = 18;
  bool has_helmet() const;
  void clear_helmet() ;
  bool helmet() const;
  void set_helmet(bool value);

  private:
  bool _internal_helmet() const;
  void _internal_set_helmet(bool value);

  public:
  // optional bool defuse_kit = 19;
  bool has_defuse_kit() const;
  void clear_defuse_kit() ;
  bool defuse_kit() const;
  void set_defuse_kit(bool value);

  private:
  bool _internal_defuse_kit() const;
  void _internal_set_defuse_kit(bool value);

  public:
  // optional int32 player_slot = 2 [default = -1];
  bool has_player_slot() const;
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLPlayerState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 20,
                                   5, 46,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLPlayerState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLWeaponState > weapons_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr clan_;
    ::CMsgVector* PROTOBUF_NULLABLE abspos_;
    ::CMsgQAngle* PROTOBUF_NULLABLE eyeangle_;
    ::CMsgVector* PROTOBUF_NULLABLE eyeangle_fwd_;
    ::int32_t account_id_;
    ::int32_t entindex_;
    int team_;
    ::int32_t health_;
    ::int32_t armor_;
    float flashed_;
    float smoked_;
    ::int32_t money_;
    ::int32_t round_kills_;
    ::int32_t round_killhs_;
    float burning_;
    bool helmet_;
    bool defuse_kit_;
    ::int32_t player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLPlayerState_class_data_;
// -------------------------------------------------------------------

class MLEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLEvent) */ {
 public:
  inline MLEvent() : MLEvent(nullptr) {}
  ~MLEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLEvent* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLEvent(::google::protobuf::internal::ConstantInitialized);

  inline MLEvent(const MLEvent& from) : MLEvent(nullptr, from) {}
  inline MLEvent(MLEvent&& from) noexcept
      : MLEvent(nullptr, std::move(from)) {}
  inline MLEvent& operator=(const MLEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLEvent& operator=(MLEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLEvent& default_instance() {
    return *reinterpret_cast<const MLEvent*>(
        &_MLEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(MLEvent& a, MLEvent& b) { a.Swap(&b); }
  inline void Swap(MLEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLEvent& from) { MLEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLEvent"; }

 protected:
  explicit MLEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLEvent& from);
  MLEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLEvent&& from) noexcept
      : MLEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kEventNameFieldNumber = 1,
  };
  // repeated .MLDict data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::MLDict* PROTOBUF_NONNULL mutable_data(int index);
  ::google::protobuf::RepeatedPtrField<::MLDict>* PROTOBUF_NONNULL mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<::MLDict>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::MLDict>* PROTOBUF_NONNULL _internal_mutable_data();
  public:
  const ::MLDict& data(int index) const;
  ::MLDict* PROTOBUF_NONNULL add_data();
  const ::google::protobuf::RepeatedPtrField<::MLDict>& data() const;
  // optional string event_name = 1;
  bool has_event_name() const;
  void clear_event_name() ;
  const std::string& event_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_name(Arg_&& arg, Args_... args);
  std::string* PROTOBUF_NONNULL mutable_event_name();
  [[nodiscard]] std::string* PROTOBUF_NULLABLE release_event_name();
  void set_allocated_event_name(std::string* PROTOBUF_NULLABLE value);

  private:
  const std::string& _internal_event_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(const std::string& value);
  std::string* PROTOBUF_NONNULL _internal_mutable_event_name();

  public:
  // @@protoc_insertion_point(class_scope:MLEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 26,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLDict > data_;
    ::google::protobuf::internal::ArenaStringPtr event_name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLEvent_class_data_;
// -------------------------------------------------------------------

class MLGameState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLGameState) */ {
 public:
  inline MLGameState() : MLGameState(nullptr) {}
  ~MLGameState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLGameState* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLGameState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLGameState(::google::protobuf::internal::ConstantInitialized);

  inline MLGameState(const MLGameState& from) : MLGameState(nullptr, from) {}
  inline MLGameState(MLGameState&& from) noexcept
      : MLGameState(nullptr, std::move(from)) {}
  inline MLGameState& operator=(const MLGameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLGameState& operator=(MLGameState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLGameState& default_instance() {
    return *reinterpret_cast<const MLGameState*>(
        &_MLGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(MLGameState& a, MLGameState& b) { a.Swap(&b); }
  inline void Swap(MLGameState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLGameState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLGameState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLGameState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLGameState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLGameState& from) { MLGameState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLGameState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLGameState"; }

 protected:
  explicit MLGameState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLGameState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLGameState& from);
  MLGameState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLGameState&& from) noexcept
      : MLGameState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayersFieldNumber = 3,
    kMatchFieldNumber = 1,
    kRoundFieldNumber = 2,
  };
  // repeated .MLPlayerState players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::MLPlayerState* PROTOBUF_NONNULL mutable_players(int index);
  ::google::protobuf::RepeatedPtrField<::MLPlayerState>* PROTOBUF_NONNULL mutable_players();

  private:
  const ::google::protobuf::RepeatedPtrField<::MLPlayerState>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::MLPlayerState>* PROTOBUF_NONNULL _internal_mutable_players();
  public:
  const ::MLPlayerState& players(int index) const;
  ::MLPlayerState* PROTOBUF_NONNULL add_players();
  const ::google::protobuf::RepeatedPtrField<::MLPlayerState>& players() const;
  // optional .MLMatchState match = 1;
  bool has_match() const;
  void clear_match() ;
  const ::MLMatchState& match() const;
  [[nodiscard]] ::MLMatchState* PROTOBUF_NULLABLE release_match();
  ::MLMatchState* PROTOBUF_NONNULL mutable_match();
  void set_allocated_match(::MLMatchState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_match(::MLMatchState* PROTOBUF_NULLABLE value);
  ::MLMatchState* PROTOBUF_NULLABLE unsafe_arena_release_match();

  private:
  const ::MLMatchState& _internal_match() const;
  ::MLMatchState* PROTOBUF_NONNULL _internal_mutable_match();

  public:
  // optional .MLRoundState round = 2;
  bool has_round() const;
  void clear_round() ;
  const ::MLRoundState& round() const;
  [[nodiscard]] ::MLRoundState* PROTOBUF_NULLABLE release_round();
  ::MLRoundState* PROTOBUF_NONNULL mutable_round();
  void set_allocated_round(::MLRoundState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_round(::MLRoundState* PROTOBUF_NULLABLE value);
  ::MLRoundState* PROTOBUF_NULLABLE unsafe_arena_release_round();

  private:
  const ::MLRoundState& _internal_round() const;
  ::MLRoundState* PROTOBUF_NONNULL _internal_mutable_round();

  public:
  // @@protoc_insertion_point(class_scope:MLGameState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLGameState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLPlayerState > players_;
    ::MLMatchState* PROTOBUF_NULLABLE match_;
    ::MLRoundState* PROTOBUF_NULLABLE round_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLGameState_class_data_;
// -------------------------------------------------------------------

class MLTick final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:MLTick) */ {
 public:
  inline MLTick() : MLTick(nullptr) {}
  ~MLTick() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MLTick* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MLTick));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MLTick(::google::protobuf::internal::ConstantInitialized);

  inline MLTick(const MLTick& from) : MLTick(nullptr, from) {}
  inline MLTick(MLTick&& from) noexcept
      : MLTick(nullptr, std::move(from)) {}
  inline MLTick& operator=(const MLTick& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLTick& operator=(MLTick&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MLTick& default_instance() {
    return *reinterpret_cast<const MLTick*>(
        &_MLTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(MLTick& a, MLTick& b) { a.Swap(&b); }
  inline void Swap(MLTick* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLTick* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MLTick* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MLTick>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MLTick& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MLTick& from) { MLTick::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MLTick* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "MLTick"; }

 protected:
  explicit MLTick(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MLTick(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MLTick& from);
  MLTick(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MLTick&& from) noexcept
      : MLTick(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsFieldNumber = 3,
    kStateFieldNumber = 2,
    kTickCountFieldNumber = 1,
  };
  // repeated .MLEvent events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::MLEvent* PROTOBUF_NONNULL mutable_events(int index);
  ::google::protobuf::RepeatedPtrField<::MLEvent>* PROTOBUF_NONNULL mutable_events();

  private:
  const ::google::protobuf::RepeatedPtrField<::MLEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::MLEvent>* PROTOBUF_NONNULL _internal_mutable_events();
  public:
  const ::MLEvent& events(int index) const;
  ::MLEvent* PROTOBUF_NONNULL add_events();
  const ::google::protobuf::RepeatedPtrField<::MLEvent>& events() const;
  // optional .MLGameState state = 2;
  bool has_state() const;
  void clear_state() ;
  const ::MLGameState& state() const;
  [[nodiscard]] ::MLGameState* PROTOBUF_NULLABLE release_state();
  ::MLGameState* PROTOBUF_NONNULL mutable_state();
  void set_allocated_state(::MLGameState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_state(::MLGameState* PROTOBUF_NULLABLE value);
  ::MLGameState* PROTOBUF_NULLABLE unsafe_arena_release_state();

  private:
  const ::MLGameState& _internal_state() const;
  ::MLGameState* PROTOBUF_NONNULL _internal_mutable_state();

  public:
  // optional int32 tick_count = 1;
  bool has_tick_count() const;
  void clear_tick_count() ;
  ::int32_t tick_count() const;
  void set_tick_count(::int32_t value);

  private:
  ::int32_t _internal_tick_count() const;
  void _internal_set_tick_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:MLTick)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MLTick& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::MLEvent > events_;
    ::MLGameState* PROTOBUF_NULLABLE state_;
    ::int32_t tick_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fatdemo_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MLTick_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MLDict

// optional string key = 1;
inline bool MLDict::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLDict::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDict::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLDict.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLDict::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLDict.key)
}
inline std::string* PROTOBUF_NONNULL MLDict::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:MLDict.key)
  return _s;
}
inline const std::string& MLDict::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void MLDict::_internal_set_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLDict::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLDict::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLDict.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void MLDict::set_allocated_key(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLDict.key)
}

// optional string val_string = 2;
inline bool MLDict::has_val_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLDict::clear_val_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLDict::val_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLDict.val_string)
  return _internal_val_string();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLDict::set_val_string(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLDict.val_string)
}
inline std::string* PROTOBUF_NONNULL MLDict::mutable_val_string()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_val_string();
  // @@protoc_insertion_point(field_mutable:MLDict.val_string)
  return _s;
}
inline const std::string& MLDict::_internal_val_string() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.val_string_.Get();
}
inline void MLDict::_internal_set_val_string(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_string_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLDict::_internal_mutable_val_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.val_string_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLDict::release_val_string() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLDict.val_string)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.val_string_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.val_string_.Set("", GetArena());
  }
  return released;
}
inline void MLDict::set_allocated_val_string(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.val_string_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.val_string_.IsDefault()) {
    _impl_.val_string_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLDict.val_string)
}

// optional int32 val_int = 3;
inline bool MLDict::has_val_int() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLDict::clear_val_int() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_int_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLDict::val_int() const {
  // @@protoc_insertion_point(field_get:MLDict.val_int)
  return _internal_val_int();
}
inline void MLDict::set_val_int(::int32_t value) {
  _internal_set_val_int(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:MLDict.val_int)
}
inline ::int32_t MLDict::_internal_val_int() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.val_int_;
}
inline void MLDict::_internal_set_val_int(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_int_ = value;
}

// optional float val_float = 4;
inline bool MLDict::has_val_float() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLDict::clear_val_float() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_float_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MLDict::val_float() const {
  // @@protoc_insertion_point(field_get:MLDict.val_float)
  return _internal_val_float();
}
inline void MLDict::set_val_float(float value) {
  _internal_set_val_float(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:MLDict.val_float)
}
inline float MLDict::_internal_val_float() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.val_float_;
}
inline void MLDict::_internal_set_val_float(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.val_float_ = value;
}

// -------------------------------------------------------------------

// MLEvent

// optional string event_name = 1;
inline bool MLEvent::has_event_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLEvent::clear_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLEvent::event_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLEvent.event_name)
  return _internal_event_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLEvent::set_event_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLEvent.event_name)
}
inline std::string* PROTOBUF_NONNULL MLEvent::mutable_event_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:MLEvent.event_name)
  return _s;
}
inline const std::string& MLEvent::_internal_event_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_name_.Get();
}
inline void MLEvent::_internal_set_event_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.event_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLEvent::_internal_mutable_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.event_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLEvent::release_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLEvent.event_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.event_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.event_name_.Set("", GetArena());
  }
  return released;
}
inline void MLEvent::set_allocated_event_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.event_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_name_.IsDefault()) {
    _impl_.event_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLEvent.event_name)
}

// repeated .MLDict data = 2;
inline int MLEvent::_internal_data_size() const {
  return _internal_data().size();
}
inline int MLEvent::data_size() const {
  return _internal_data_size();
}
inline void MLEvent::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::MLDict* PROTOBUF_NONNULL MLEvent::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:MLEvent.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MLDict>* PROTOBUF_NONNULL MLEvent::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MLEvent.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::MLDict& MLEvent::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLEvent.data)
  return _internal_data().Get(index);
}
inline ::MLDict* PROTOBUF_NONNULL MLEvent::add_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MLDict* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:MLEvent.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MLDict>& MLEvent::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MLEvent.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::MLDict>&
MLEvent::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::MLDict>* PROTOBUF_NONNULL
MLEvent::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// MLMatchState

// optional string game_mode = 1;
inline bool MLMatchState::has_game_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLMatchState::clear_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_mode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLMatchState::game_mode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLMatchState.game_mode)
  return _internal_game_mode();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLMatchState::set_game_mode(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_mode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLMatchState.game_mode)
}
inline std::string* PROTOBUF_NONNULL MLMatchState::mutable_game_mode()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_game_mode();
  // @@protoc_insertion_point(field_mutable:MLMatchState.game_mode)
  return _s;
}
inline const std::string& MLMatchState::_internal_game_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.game_mode_.Get();
}
inline void MLMatchState::_internal_set_game_mode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.game_mode_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLMatchState::_internal_mutable_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.game_mode_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLMatchState::release_game_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLMatchState.game_mode)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.game_mode_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.game_mode_.Set("", GetArena());
  }
  return released;
}
inline void MLMatchState::set_allocated_game_mode(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.game_mode_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.game_mode_.IsDefault()) {
    _impl_.game_mode_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.game_mode)
}

// optional string phase = 2;
inline bool MLMatchState::has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLMatchState::clear_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLMatchState::phase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLMatchState.phase)
  return _internal_phase();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLMatchState::set_phase(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLMatchState.phase)
}
inline std::string* PROTOBUF_NONNULL MLMatchState::mutable_phase()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLMatchState.phase)
  return _s;
}
inline const std::string& MLMatchState::_internal_phase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phase_.Get();
}
inline void MLMatchState::_internal_set_phase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLMatchState::_internal_mutable_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.phase_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLMatchState::release_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLMatchState.phase)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.phase_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.phase_.Set("", GetArena());
  }
  return released;
}
inline void MLMatchState::set_allocated_phase(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.phase_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLMatchState.phase)
}

// optional int32 round = 3;
inline bool MLMatchState::has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLMatchState::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLMatchState::round() const {
  // @@protoc_insertion_point(field_get:MLMatchState.round)
  return _internal_round();
}
inline void MLMatchState::set_round(::int32_t value) {
  _internal_set_round(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:MLMatchState.round)
}
inline ::int32_t MLMatchState::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_;
}
inline void MLMatchState::_internal_set_round(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_ = value;
}

// optional int32 score_ct = 4;
inline bool MLMatchState::has_score_ct() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLMatchState::clear_score_ct() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ct_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MLMatchState::score_ct() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_ct)
  return _internal_score_ct();
}
inline void MLMatchState::set_score_ct(::int32_t value) {
  _internal_set_score_ct(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:MLMatchState.score_ct)
}
inline ::int32_t MLMatchState::_internal_score_ct() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_ct_;
}
inline void MLMatchState::_internal_set_score_ct(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_ct_ = value;
}

// optional int32 score_t = 5;
inline bool MLMatchState::has_score_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MLMatchState::clear_score_t() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_t_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MLMatchState::score_t() const {
  // @@protoc_insertion_point(field_get:MLMatchState.score_t)
  return _internal_score_t();
}
inline void MLMatchState::set_score_t(::int32_t value) {
  _internal_set_score_t(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:MLMatchState.score_t)
}
inline ::int32_t MLMatchState::_internal_score_t() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.score_t_;
}
inline void MLMatchState::_internal_set_score_t(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.score_t_ = value;
}

// -------------------------------------------------------------------

// MLRoundState

// optional string phase = 1;
inline bool MLRoundState::has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLRoundState::clear_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phase_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLRoundState::phase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLRoundState.phase)
  return _internal_phase();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLRoundState::set_phase(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLRoundState.phase)
}
inline std::string* PROTOBUF_NONNULL MLRoundState::mutable_phase()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phase();
  // @@protoc_insertion_point(field_mutable:MLRoundState.phase)
  return _s;
}
inline const std::string& MLRoundState::_internal_phase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phase_.Get();
}
inline void MLRoundState::_internal_set_phase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phase_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLRoundState::_internal_mutable_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phase_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLRoundState::release_phase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLRoundState.phase)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.phase_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.phase_.Set("", GetArena());
  }
  return released;
}
inline void MLRoundState::set_allocated_phase(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phase_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phase_.IsDefault()) {
    _impl_.phase_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.phase)
}

// optional .ETeam win_team = 2 [default = ET_Unknown];
inline bool MLRoundState::has_win_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLRoundState::clear_win_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.win_team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::ETeam MLRoundState::win_team() const {
  // @@protoc_insertion_point(field_get:MLRoundState.win_team)
  return _internal_win_team();
}
inline void MLRoundState::set_win_team(::ETeam value) {
  _internal_set_win_team(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:MLRoundState.win_team)
}
inline ::ETeam MLRoundState::_internal_win_team() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ETeam>(_impl_.win_team_);
}
inline void MLRoundState::_internal_set_win_team(::ETeam value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::ETeam_internal_data_));
                                          _impl_.win_team_ = value;
}

// optional string bomb_state = 3;
inline bool MLRoundState::has_bomb_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLRoundState::clear_bomb_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bomb_state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLRoundState::bomb_state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLRoundState.bomb_state)
  return _internal_bomb_state();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLRoundState::set_bomb_state(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bomb_state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLRoundState.bomb_state)
}
inline std::string* PROTOBUF_NONNULL MLRoundState::mutable_bomb_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bomb_state();
  // @@protoc_insertion_point(field_mutable:MLRoundState.bomb_state)
  return _s;
}
inline const std::string& MLRoundState::_internal_bomb_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bomb_state_.Get();
}
inline void MLRoundState::_internal_set_bomb_state(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bomb_state_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLRoundState::_internal_mutable_bomb_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bomb_state_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLRoundState::release_bomb_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLRoundState.bomb_state)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bomb_state_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bomb_state_.Set("", GetArena());
  }
  return released;
}
inline void MLRoundState::set_allocated_bomb_state(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bomb_state_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bomb_state_.IsDefault()) {
    _impl_.bomb_state_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLRoundState.bomb_state)
}

// -------------------------------------------------------------------

// MLWeaponState

// optional int32 index = 1;
inline bool MLWeaponState::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLWeaponState::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MLWeaponState::index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.index)
  return _internal_index();
}
inline void MLWeaponState::set_index(::int32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:MLWeaponState.index)
}
inline ::int32_t MLWeaponState::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void MLWeaponState::_internal_set_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// optional string name = 2;
inline bool MLWeaponState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLWeaponState::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLWeaponState::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLWeaponState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLWeaponState::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLWeaponState.name)
}
inline std::string* PROTOBUF_NONNULL MLWeaponState::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.name)
  return _s;
}
inline const std::string& MLWeaponState::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MLWeaponState::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLWeaponState::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLWeaponState::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLWeaponState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void MLWeaponState::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.name)
}

// optional .EWeaponType type = 3 [default = EWT_Knife];
inline bool MLWeaponState::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLWeaponState::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::EWeaponType MLWeaponState::type() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.type)
  return _internal_type();
}
inline void MLWeaponState::set_type(::EWeaponType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:MLWeaponState.type)
}
inline ::EWeaponType MLWeaponState::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::EWeaponType>(_impl_.type_);
}
inline void MLWeaponState::_internal_set_type(::EWeaponType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::EWeaponType_internal_data_));
                                          _impl_.type_ = value;
}

// optional int32 ammo_clip = 4;
inline bool MLWeaponState::has_ammo_clip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_clip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_clip_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MLWeaponState::ammo_clip() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip)
  return _internal_ammo_clip();
}
inline void MLWeaponState::set_ammo_clip(::int32_t value) {
  _internal_set_ammo_clip(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip)
}
inline ::int32_t MLWeaponState::_internal_ammo_clip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ammo_clip_;
}
inline void MLWeaponState::_internal_set_ammo_clip(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_clip_ = value;
}

// optional int32 ammo_clip_max = 5;
inline bool MLWeaponState::has_ammo_clip_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_clip_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_clip_max_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MLWeaponState::ammo_clip_max() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_clip_max)
  return _internal_ammo_clip_max();
}
inline void MLWeaponState::set_ammo_clip_max(::int32_t value) {
  _internal_set_ammo_clip_max(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_clip_max)
}
inline ::int32_t MLWeaponState::_internal_ammo_clip_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ammo_clip_max_;
}
inline void MLWeaponState::_internal_set_ammo_clip_max(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_clip_max_ = value;
}

// optional int32 ammo_reserve = 6;
inline bool MLWeaponState::has_ammo_reserve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MLWeaponState::clear_ammo_reserve() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_reserve_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MLWeaponState::ammo_reserve() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.ammo_reserve)
  return _internal_ammo_reserve();
}
inline void MLWeaponState::set_ammo_reserve(::int32_t value) {
  _internal_set_ammo_reserve(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:MLWeaponState.ammo_reserve)
}
inline ::int32_t MLWeaponState::_internal_ammo_reserve() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ammo_reserve_;
}
inline void MLWeaponState::_internal_set_ammo_reserve(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ammo_reserve_ = value;
}

// optional string state = 7;
inline bool MLWeaponState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLWeaponState::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLWeaponState::state() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLWeaponState.state)
  return _internal_state();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLWeaponState::set_state(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLWeaponState.state)
}
inline std::string* PROTOBUF_NONNULL MLWeaponState::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLWeaponState.state)
  return _s;
}
inline const std::string& MLWeaponState::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.state_.Get();
}
inline void MLWeaponState::_internal_set_state(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.state_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLWeaponState::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.state_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLWeaponState::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLWeaponState.state)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.state_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.state_.Set("", GetArena());
  }
  return released;
}
inline void MLWeaponState::set_allocated_state(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.state_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLWeaponState.state)
}

// optional float recoil_index = 8;
inline bool MLWeaponState::has_recoil_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MLWeaponState::clear_recoil_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recoil_index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MLWeaponState::recoil_index() const {
  // @@protoc_insertion_point(field_get:MLWeaponState.recoil_index)
  return _internal_recoil_index();
}
inline void MLWeaponState::set_recoil_index(float value) {
  _internal_set_recoil_index(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:MLWeaponState.recoil_index)
}
inline float MLWeaponState::_internal_recoil_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recoil_index_;
}
inline void MLWeaponState::_internal_set_recoil_index(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recoil_index_ = value;
}

// -------------------------------------------------------------------

// MLPlayerState

// optional int32 account_id = 1;
inline bool MLPlayerState::has_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MLPlayerState::clear_account_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MLPlayerState::account_id() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.account_id)
  return _internal_account_id();
}
inline void MLPlayerState::set_account_id(::int32_t value) {
  _internal_set_account_id(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:MLPlayerState.account_id)
}
inline ::int32_t MLPlayerState::_internal_account_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_id_;
}
inline void MLPlayerState::_internal_set_account_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_id_ = value;
}

// optional int32 player_slot = 2 [default = -1];
inline bool MLPlayerState::has_player_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void MLPlayerState::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = -1;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int32_t MLPlayerState::player_slot() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.player_slot)
  return _internal_player_slot();
}
inline void MLPlayerState::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.player_slot)
}
inline ::int32_t MLPlayerState::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void MLPlayerState::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// optional int32 entindex = 3;
inline bool MLPlayerState::has_entindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MLPlayerState::clear_entindex() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MLPlayerState::entindex() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.entindex)
  return _internal_entindex();
}
inline void MLPlayerState::set_entindex(::int32_t value) {
  _internal_set_entindex(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:MLPlayerState.entindex)
}
inline ::int32_t MLPlayerState::_internal_entindex() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entindex_;
}
inline void MLPlayerState::_internal_set_entindex(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entindex_ = value;
}

// optional string name = 4;
inline bool MLPlayerState::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLPlayerState::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLPlayerState::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLPlayerState::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLPlayerState.name)
}
inline std::string* PROTOBUF_NONNULL MLPlayerState::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.name)
  return _s;
}
inline const std::string& MLPlayerState::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void MLPlayerState::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLPlayerState::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLPlayerState::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLPlayerState.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void MLPlayerState::set_allocated_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.name)
}

// optional string clan = 5;
inline bool MLPlayerState::has_clan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLPlayerState::clear_clan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.clan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MLPlayerState::clan() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.clan)
  return _internal_clan();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLPlayerState::set_clan(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clan_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLPlayerState.clan)
}
inline std::string* PROTOBUF_NONNULL MLPlayerState::mutable_clan()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clan();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.clan)
  return _s;
}
inline const std::string& MLPlayerState::_internal_clan() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.clan_.Get();
}
inline void MLPlayerState::_internal_set_clan(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.clan_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLPlayerState::_internal_mutable_clan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.clan_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLPlayerState::release_clan() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLPlayerState.clan)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.clan_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.clan_.Set("", GetArena());
  }
  return released;
}
inline void MLPlayerState::set_allocated_clan(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.clan_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.clan_.IsDefault()) {
    _impl_.clan_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.clan)
}

// optional .ETeam team = 6 [default = ET_Unknown];
inline bool MLPlayerState::has_team() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MLPlayerState::clear_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.team_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::ETeam MLPlayerState::team() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.team)
  return _internal_team();
}
inline void MLPlayerState::set_team(::ETeam value) {
  _internal_set_team(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:MLPlayerState.team)
}
inline ::ETeam MLPlayerState::_internal_team() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ETeam>(_impl_.team_);
}
inline void MLPlayerState::_internal_set_team(::ETeam value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);

                                          assert(::google::protobuf::internal::ValidateEnum(
                                              value, ::ETeam_internal_data_));
                                          _impl_.team_ = value;
}

// optional .CMsgVector abspos = 7;
inline bool MLPlayerState::has_abspos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.abspos_ != nullptr);
  return value;
}
inline const ::CMsgVector& MLPlayerState::_internal_abspos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CMsgVector* p = _impl_.abspos_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::abspos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.abspos)
  return _internal_abspos();
}
inline void MLPlayerState::unsafe_arena_set_allocated_abspos(
    ::CMsgVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.abspos_);
  }
  _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.abspos)
}
inline ::CMsgVector* PROTOBUF_NULLABLE MLPlayerState::release_abspos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* released = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CMsgVector* PROTOBUF_NULLABLE MLPlayerState::unsafe_arena_release_abspos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLPlayerState.abspos)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::CMsgVector* temp = _impl_.abspos_;
  _impl_.abspos_ = nullptr;
  return temp;
}
inline ::CMsgVector* PROTOBUF_NONNULL MLPlayerState::_internal_mutable_abspos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.abspos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::CMsgVector>(GetArena());
    _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(p);
  }
  return _impl_.abspos_;
}
inline ::CMsgVector* PROTOBUF_NONNULL MLPlayerState::mutable_abspos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::CMsgVector* _msg = _internal_mutable_abspos();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.abspos)
  return _msg;
}
inline void MLPlayerState::set_allocated_abspos(::CMsgVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.abspos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.abspos_ = reinterpret_cast<::CMsgVector*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.abspos)
}

// optional .CMsgQAngle eyeangle = 8;
inline bool MLPlayerState::has_eyeangle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_ != nullptr);
  return value;
}
inline const ::CMsgQAngle& MLPlayerState::_internal_eyeangle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CMsgQAngle* p = _impl_.eyeangle_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgQAngle&>(::_CMsgQAngle_default_instance_);
}
inline const ::CMsgQAngle& MLPlayerState::eyeangle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle)
  return _internal_eyeangle();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle(
    ::CMsgQAngle* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_);
  }
  _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle)
}
inline ::CMsgQAngle* PROTOBUF_NULLABLE MLPlayerState::release_eyeangle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* released = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CMsgQAngle* PROTOBUF_NULLABLE MLPlayerState::unsafe_arena_release_eyeangle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::CMsgQAngle* temp = _impl_.eyeangle_;
  _impl_.eyeangle_ = nullptr;
  return temp;
}
inline ::CMsgQAngle* PROTOBUF_NONNULL MLPlayerState::_internal_mutable_eyeangle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eyeangle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::CMsgQAngle>(GetArena());
    _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(p);
  }
  return _impl_.eyeangle_;
}
inline ::CMsgQAngle* PROTOBUF_NONNULL MLPlayerState::mutable_eyeangle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::CMsgQAngle* _msg = _internal_mutable_eyeangle();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle(::CMsgQAngle* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.eyeangle_ = reinterpret_cast<::CMsgQAngle*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle)
}

// optional .CMsgVector eyeangle_fwd = 9;
inline bool MLPlayerState::has_eyeangle_fwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.eyeangle_fwd_ != nullptr);
  return value;
}
inline const ::CMsgVector& MLPlayerState::_internal_eyeangle_fwd() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::CMsgVector* p = _impl_.eyeangle_fwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgVector&>(::_CMsgVector_default_instance_);
}
inline const ::CMsgVector& MLPlayerState::eyeangle_fwd() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.eyeangle_fwd)
  return _internal_eyeangle_fwd();
}
inline void MLPlayerState::unsafe_arena_set_allocated_eyeangle_fwd(
    ::CMsgVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_fwd_);
  }
  _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLPlayerState.eyeangle_fwd)
}
inline ::CMsgVector* PROTOBUF_NULLABLE MLPlayerState::release_eyeangle_fwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* released = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::CMsgVector* PROTOBUF_NULLABLE MLPlayerState::unsafe_arena_release_eyeangle_fwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLPlayerState.eyeangle_fwd)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::CMsgVector* temp = _impl_.eyeangle_fwd_;
  _impl_.eyeangle_fwd_ = nullptr;
  return temp;
}
inline ::CMsgVector* PROTOBUF_NONNULL MLPlayerState::_internal_mutable_eyeangle_fwd() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.eyeangle_fwd_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::CMsgVector>(GetArena());
    _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(p);
  }
  return _impl_.eyeangle_fwd_;
}
inline ::CMsgVector* PROTOBUF_NONNULL MLPlayerState::mutable_eyeangle_fwd()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::CMsgVector* _msg = _internal_mutable_eyeangle_fwd();
  // @@protoc_insertion_point(field_mutable:MLPlayerState.eyeangle_fwd)
  return _msg;
}
inline void MLPlayerState::set_allocated_eyeangle_fwd(::CMsgVector* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.eyeangle_fwd_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.eyeangle_fwd_ = reinterpret_cast<::CMsgVector*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLPlayerState.eyeangle_fwd)
}

// optional int32 health = 10;
inline bool MLPlayerState::has_health() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MLPlayerState::clear_health() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t MLPlayerState::health() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.health)
  return _internal_health();
}
inline void MLPlayerState::set_health(::int32_t value) {
  _internal_set_health(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:MLPlayerState.health)
}
inline ::int32_t MLPlayerState::_internal_health() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_;
}
inline void MLPlayerState::_internal_set_health(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_ = value;
}

// optional int32 armor = 11;
inline bool MLPlayerState::has_armor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MLPlayerState::clear_armor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t MLPlayerState::armor() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.armor)
  return _internal_armor();
}
inline void MLPlayerState::set_armor(::int32_t value) {
  _internal_set_armor(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:MLPlayerState.armor)
}
inline ::int32_t MLPlayerState::_internal_armor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.armor_;
}
inline void MLPlayerState::_internal_set_armor(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.armor_ = value;
}

// optional float flashed = 12;
inline bool MLPlayerState::has_flashed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void MLPlayerState::clear_flashed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flashed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float MLPlayerState::flashed() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.flashed)
  return _internal_flashed();
}
inline void MLPlayerState::set_flashed(float value) {
  _internal_set_flashed(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:MLPlayerState.flashed)
}
inline float MLPlayerState::_internal_flashed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flashed_;
}
inline void MLPlayerState::_internal_set_flashed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flashed_ = value;
}

// optional float smoked = 13;
inline bool MLPlayerState::has_smoked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void MLPlayerState::clear_smoked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.smoked_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float MLPlayerState::smoked() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.smoked)
  return _internal_smoked();
}
inline void MLPlayerState::set_smoked(float value) {
  _internal_set_smoked(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:MLPlayerState.smoked)
}
inline float MLPlayerState::_internal_smoked() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.smoked_;
}
inline void MLPlayerState::_internal_set_smoked(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.smoked_ = value;
}

// optional int32 money = 14;
inline bool MLPlayerState::has_money() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void MLPlayerState::clear_money() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.money_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t MLPlayerState::money() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.money)
  return _internal_money();
}
inline void MLPlayerState::set_money(::int32_t value) {
  _internal_set_money(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.money)
}
inline ::int32_t MLPlayerState::_internal_money() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.money_;
}
inline void MLPlayerState::_internal_set_money(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.money_ = value;
}

// optional int32 round_kills = 15;
inline bool MLPlayerState::has_round_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void MLPlayerState::clear_round_kills() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t MLPlayerState::round_kills() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_kills)
  return _internal_round_kills();
}
inline void MLPlayerState::set_round_kills(::int32_t value) {
  _internal_set_round_kills(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.round_kills)
}
inline ::int32_t MLPlayerState::_internal_round_kills() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_kills_;
}
inline void MLPlayerState::_internal_set_round_kills(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_kills_ = value;
}

// optional int32 round_killhs = 16;
inline bool MLPlayerState::has_round_killhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void MLPlayerState::clear_round_killhs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_killhs_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t MLPlayerState::round_killhs() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.round_killhs)
  return _internal_round_killhs();
}
inline void MLPlayerState::set_round_killhs(::int32_t value) {
  _internal_set_round_killhs(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.round_killhs)
}
inline ::int32_t MLPlayerState::_internal_round_killhs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_killhs_;
}
inline void MLPlayerState::_internal_set_round_killhs(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_killhs_ = value;
}

// optional float burning = 17;
inline bool MLPlayerState::has_burning() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void MLPlayerState::clear_burning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.burning_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline float MLPlayerState::burning() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.burning)
  return _internal_burning();
}
inline void MLPlayerState::set_burning(float value) {
  _internal_set_burning(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.burning)
}
inline float MLPlayerState::_internal_burning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.burning_;
}
inline void MLPlayerState::_internal_set_burning(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.burning_ = value;
}

// optional bool helmet = 18;
inline bool MLPlayerState::has_helmet() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void MLPlayerState::clear_helmet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.helmet_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool MLPlayerState::helmet() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.helmet)
  return _internal_helmet();
}
inline void MLPlayerState::set_helmet(bool value) {
  _internal_set_helmet(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.helmet)
}
inline bool MLPlayerState::_internal_helmet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.helmet_;
}
inline void MLPlayerState::_internal_set_helmet(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.helmet_ = value;
}

// optional bool defuse_kit = 19;
inline bool MLPlayerState::has_defuse_kit() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void MLPlayerState::clear_defuse_kit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defuse_kit_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool MLPlayerState::defuse_kit() const {
  // @@protoc_insertion_point(field_get:MLPlayerState.defuse_kit)
  return _internal_defuse_kit();
}
inline void MLPlayerState::set_defuse_kit(bool value) {
  _internal_set_defuse_kit(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:MLPlayerState.defuse_kit)
}
inline bool MLPlayerState::_internal_defuse_kit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.defuse_kit_;
}
inline void MLPlayerState::_internal_set_defuse_kit(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.defuse_kit_ = value;
}

// repeated .MLWeaponState weapons = 20;
inline int MLPlayerState::_internal_weapons_size() const {
  return _internal_weapons().size();
}
inline int MLPlayerState::weapons_size() const {
  return _internal_weapons_size();
}
inline void MLPlayerState::clear_weapons() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapons_.Clear();
}
inline ::MLWeaponState* PROTOBUF_NONNULL MLPlayerState::mutable_weapons(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:MLPlayerState.weapons)
  return _internal_mutable_weapons()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MLWeaponState>* PROTOBUF_NONNULL MLPlayerState::mutable_weapons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MLPlayerState.weapons)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_weapons();
}
inline const ::MLWeaponState& MLPlayerState::weapons(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLPlayerState.weapons)
  return _internal_weapons().Get(index);
}
inline ::MLWeaponState* PROTOBUF_NONNULL MLPlayerState::add_weapons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MLWeaponState* _add = _internal_mutable_weapons()->Add();
  // @@protoc_insertion_point(field_add:MLPlayerState.weapons)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MLWeaponState>& MLPlayerState::weapons() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MLPlayerState.weapons)
  return _internal_weapons();
}
inline const ::google::protobuf::RepeatedPtrField<::MLWeaponState>&
MLPlayerState::_internal_weapons() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapons_;
}
inline ::google::protobuf::RepeatedPtrField<::MLWeaponState>* PROTOBUF_NONNULL
MLPlayerState::_internal_mutable_weapons() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.weapons_;
}

// -------------------------------------------------------------------

// MLGameState

// optional .MLMatchState match = 1;
inline bool MLGameState::has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.match_ != nullptr);
  return value;
}
inline void MLGameState::clear_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ != nullptr) _impl_.match_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLMatchState& MLGameState::_internal_match() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::MLMatchState* p = _impl_.match_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLMatchState&>(::_MLMatchState_default_instance_);
}
inline const ::MLMatchState& MLGameState::match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLGameState.match)
  return _internal_match();
}
inline void MLGameState::unsafe_arena_set_allocated_match(
    ::MLMatchState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }
  _impl_.match_ = reinterpret_cast<::MLMatchState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.match)
}
inline ::MLMatchState* PROTOBUF_NULLABLE MLGameState::release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* released = _impl_.match_;
  _impl_.match_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::MLMatchState* PROTOBUF_NULLABLE MLGameState::unsafe_arena_release_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLGameState.match)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLMatchState* temp = _impl_.match_;
  _impl_.match_ = nullptr;
  return temp;
}
inline ::MLMatchState* PROTOBUF_NONNULL MLGameState::_internal_mutable_match() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.match_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MLMatchState>(GetArena());
    _impl_.match_ = reinterpret_cast<::MLMatchState*>(p);
  }
  return _impl_.match_;
}
inline ::MLMatchState* PROTOBUF_NONNULL MLGameState::mutable_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MLMatchState* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:MLGameState.match)
  return _msg;
}
inline void MLGameState::set_allocated_match(::MLMatchState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.match_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.match_ = reinterpret_cast<::MLMatchState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLGameState.match)
}

// optional .MLRoundState round = 2;
inline bool MLGameState::has_round() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.round_ != nullptr);
  return value;
}
inline void MLGameState::clear_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.round_ != nullptr) _impl_.round_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::MLRoundState& MLGameState::_internal_round() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::MLRoundState* p = _impl_.round_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLRoundState&>(::_MLRoundState_default_instance_);
}
inline const ::MLRoundState& MLGameState::round() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLGameState.round)
  return _internal_round();
}
inline void MLGameState::unsafe_arena_set_allocated_round(
    ::MLRoundState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.round_);
  }
  _impl_.round_ = reinterpret_cast<::MLRoundState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLGameState.round)
}
inline ::MLRoundState* PROTOBUF_NULLABLE MLGameState::release_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* released = _impl_.round_;
  _impl_.round_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::MLRoundState* PROTOBUF_NULLABLE MLGameState::unsafe_arena_release_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLGameState.round)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::MLRoundState* temp = _impl_.round_;
  _impl_.round_ = nullptr;
  return temp;
}
inline ::MLRoundState* PROTOBUF_NONNULL MLGameState::_internal_mutable_round() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.round_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MLRoundState>(GetArena());
    _impl_.round_ = reinterpret_cast<::MLRoundState*>(p);
  }
  return _impl_.round_;
}
inline ::MLRoundState* PROTOBUF_NONNULL MLGameState::mutable_round()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::MLRoundState* _msg = _internal_mutable_round();
  // @@protoc_insertion_point(field_mutable:MLGameState.round)
  return _msg;
}
inline void MLGameState::set_allocated_round(::MLRoundState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.round_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.round_ = reinterpret_cast<::MLRoundState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLGameState.round)
}

// repeated .MLPlayerState players = 3;
inline int MLGameState::_internal_players_size() const {
  return _internal_players().size();
}
inline int MLGameState::players_size() const {
  return _internal_players_size();
}
inline void MLGameState::clear_players() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.players_.Clear();
}
inline ::MLPlayerState* PROTOBUF_NONNULL MLGameState::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:MLGameState.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MLPlayerState>* PROTOBUF_NONNULL MLGameState::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MLGameState.players)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_players();
}
inline const ::MLPlayerState& MLGameState::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLGameState.players)
  return _internal_players().Get(index);
}
inline ::MLPlayerState* PROTOBUF_NONNULL MLGameState::add_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MLPlayerState* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:MLGameState.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MLPlayerState>& MLGameState::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MLGameState.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::MLPlayerState>&
MLGameState::_internal_players() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::MLPlayerState>* PROTOBUF_NONNULL
MLGameState::_internal_mutable_players() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// MLDemoHeader

// optional string map_name = 1;
inline bool MLDemoHeader::has_map_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MLDemoHeader::clear_map_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.map_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MLDemoHeader::map_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLDemoHeader.map_name)
  return _internal_map_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void MLDemoHeader::set_map_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:MLDemoHeader.map_name)
}
inline std::string* PROTOBUF_NONNULL MLDemoHeader::mutable_map_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:MLDemoHeader.map_name)
  return _s;
}
inline const std::string& MLDemoHeader::_internal_map_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.map_name_.Get();
}
inline void MLDemoHeader::_internal_set_map_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.map_name_.Set(value, GetArena());
}
inline std::string* PROTOBUF_NONNULL MLDemoHeader::_internal_mutable_map_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.map_name_.Mutable( GetArena());
}
inline std::string* PROTOBUF_NULLABLE MLDemoHeader::release_map_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLDemoHeader.map_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.map_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.map_name_.Set("", GetArena());
  }
  return released;
}
inline void MLDemoHeader::set_allocated_map_name(std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.map_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.map_name_.IsDefault()) {
    _impl_.map_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:MLDemoHeader.map_name)
}

// optional int32 tick_rate = 2;
inline bool MLDemoHeader::has_tick_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLDemoHeader::clear_tick_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MLDemoHeader::tick_rate() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.tick_rate)
  return _internal_tick_rate();
}
inline void MLDemoHeader::set_tick_rate(::int32_t value) {
  _internal_set_tick_rate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:MLDemoHeader.tick_rate)
}
inline ::int32_t MLDemoHeader::_internal_tick_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tick_rate_;
}
inline void MLDemoHeader::_internal_set_tick_rate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_rate_ = value;
}

// optional uint32 version = 3;
inline bool MLDemoHeader::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MLDemoHeader::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t MLDemoHeader::version() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.version)
  return _internal_version();
}
inline void MLDemoHeader::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:MLDemoHeader.version)
}
inline ::uint32_t MLDemoHeader::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void MLDemoHeader::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// optional uint32 steam_universe = 4;
inline bool MLDemoHeader::has_steam_universe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MLDemoHeader::clear_steam_universe() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steam_universe_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t MLDemoHeader::steam_universe() const {
  // @@protoc_insertion_point(field_get:MLDemoHeader.steam_universe)
  return _internal_steam_universe();
}
inline void MLDemoHeader::set_steam_universe(::uint32_t value) {
  _internal_set_steam_universe(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:MLDemoHeader.steam_universe)
}
inline ::uint32_t MLDemoHeader::_internal_steam_universe() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.steam_universe_;
}
inline void MLDemoHeader::_internal_set_steam_universe(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steam_universe_ = value;
}

// -------------------------------------------------------------------

// MLTick

// optional int32 tick_count = 1;
inline bool MLTick::has_tick_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MLTick::clear_tick_count() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MLTick::tick_count() const {
  // @@protoc_insertion_point(field_get:MLTick.tick_count)
  return _internal_tick_count();
}
inline void MLTick::set_tick_count(::int32_t value) {
  _internal_set_tick_count(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:MLTick.tick_count)
}
inline ::int32_t MLTick::_internal_tick_count() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tick_count_;
}
inline void MLTick::_internal_set_tick_count(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tick_count_ = value;
}

// optional .MLGameState state = 2;
inline bool MLTick::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.state_ != nullptr);
  return value;
}
inline void MLTick::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ != nullptr) _impl_.state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::MLGameState& MLTick::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::MLGameState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::MLGameState&>(::_MLGameState_default_instance_);
}
inline const ::MLGameState& MLTick::state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLTick.state)
  return _internal_state();
}
inline void MLTick::unsafe_arena_set_allocated_state(
    ::MLGameState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = reinterpret_cast<::MLGameState*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MLTick.state)
}
inline ::MLGameState* PROTOBUF_NULLABLE MLTick::release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* released = _impl_.state_;
  _impl_.state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::MLGameState* PROTOBUF_NULLABLE MLTick::unsafe_arena_release_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:MLTick.state)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::MLGameState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::MLGameState* PROTOBUF_NONNULL MLTick::_internal_mutable_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::MLGameState>(GetArena());
    _impl_.state_ = reinterpret_cast<::MLGameState*>(p);
  }
  return _impl_.state_;
}
inline ::MLGameState* PROTOBUF_NONNULL MLTick::mutable_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::MLGameState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:MLTick.state)
  return _msg;
}
inline void MLTick::set_allocated_state(::MLGameState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.state_ = reinterpret_cast<::MLGameState*>(value);
  // @@protoc_insertion_point(field_set_allocated:MLTick.state)
}

// repeated .MLEvent events = 3;
inline int MLTick::_internal_events_size() const {
  return _internal_events().size();
}
inline int MLTick::events_size() const {
  return _internal_events_size();
}
inline void MLTick::clear_events() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.events_.Clear();
}
inline ::MLEvent* PROTOBUF_NONNULL MLTick::mutable_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:MLTick.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::MLEvent>* PROTOBUF_NONNULL MLTick::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:MLTick.events)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_events();
}
inline const ::MLEvent& MLTick::events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:MLTick.events)
  return _internal_events().Get(index);
}
inline ::MLEvent* PROTOBUF_NONNULL MLTick::add_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::MLEvent* _add = _internal_mutable_events()->Add();
  // @@protoc_insertion_point(field_add:MLTick.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::MLEvent>& MLTick::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:MLTick.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::MLEvent>&
MLTick::_internal_events() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::MLEvent>* PROTOBUF_NONNULL
MLTick::_internal_mutable_events() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.events_;
}

// -------------------------------------------------------------------

// VacNetShot

// optional fixed64 steamid_player = 1;
inline bool VacNetShot::has_steamid_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VacNetShot::clear_steamid_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steamid_player_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t VacNetShot::steamid_player() const {
  // @@protoc_insertion_point(field_get:VacNetShot.steamid_player)
  return _internal_steamid_player();
}
inline void VacNetShot::set_steamid_player(::uint64_t value) {
  _internal_set_steamid_player(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:VacNetShot.steamid_player)
}
inline ::uint64_t VacNetShot::_internal_steamid_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.steamid_player_;
}
inline void VacNetShot::_internal_set_steamid_player(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.steamid_player_ = value;
}

// optional int32 round_number = 2;
inline bool VacNetShot::has_round_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VacNetShot::clear_round_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t VacNetShot::round_number() const {
  // @@protoc_insertion_point(field_get:VacNetShot.round_number)
  return _internal_round_number();
}
inline void VacNetShot::set_round_number(::int32_t value) {
  _internal_set_round_number(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:VacNetShot.round_number)
}
inline ::int32_t VacNetShot::_internal_round_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_number_;
}
inline void VacNetShot::_internal_set_round_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = value;
}

// optional int32 hit_type = 3;
inline bool VacNetShot::has_hit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VacNetShot::clear_hit_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t VacNetShot::hit_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.hit_type)
  return _internal_hit_type();
}
inline void VacNetShot::set_hit_type(::int32_t value) {
  _internal_set_hit_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:VacNetShot.hit_type)
}
inline ::int32_t VacNetShot::_internal_hit_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hit_type_;
}
inline void VacNetShot::_internal_set_hit_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hit_type_ = value;
}

// optional int32 weapon_type = 4;
inline bool VacNetShot::has_weapon_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VacNetShot::clear_weapon_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t VacNetShot::weapon_type() const {
  // @@protoc_insertion_point(field_get:VacNetShot.weapon_type)
  return _internal_weapon_type();
}
inline void VacNetShot::set_weapon_type(::int32_t value) {
  _internal_set_weapon_type(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:VacNetShot.weapon_type)
}
inline ::int32_t VacNetShot::_internal_weapon_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.weapon_type_;
}
inline void VacNetShot::_internal_set_weapon_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.weapon_type_ = value;
}

// optional float distance_to_hurt_target = 5;
inline bool VacNetShot::has_distance_to_hurt_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VacNetShot::clear_distance_to_hurt_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_to_hurt_target_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float VacNetShot::distance_to_hurt_target() const {
  // @@protoc_insertion_point(field_get:VacNetShot.distance_to_hurt_target)
  return _internal_distance_to_hurt_target();
}
inline void VacNetShot::set_distance_to_hurt_target(float value) {
  _internal_set_distance_to_hurt_target(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:VacNetShot.distance_to_hurt_target)
}
inline float VacNetShot::_internal_distance_to_hurt_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.distance_to_hurt_target_;
}
inline void VacNetShot::_internal_set_distance_to_hurt_target(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.distance_to_hurt_target_ = value;
}

// repeated float delta_yaw_window = 6;
inline int VacNetShot::_internal_delta_yaw_window_size() const {
  return _internal_delta_yaw_window().size();
}
inline int VacNetShot::delta_yaw_window_size() const {
  return _internal_delta_yaw_window_size();
}
inline void VacNetShot::clear_delta_yaw_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delta_yaw_window_.Clear();
}
inline float VacNetShot::delta_yaw_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window().Get(index);
}
inline void VacNetShot::set_delta_yaw_window(int index, float value) {
  _internal_mutable_delta_yaw_window()->Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_yaw_window)
}
inline void VacNetShot::add_delta_yaw_window(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_delta_yaw_window()->Add(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_yaw_window)
}
inline const ::google::protobuf::RepeatedField<float>& VacNetShot::delta_yaw_window() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_yaw_window)
  return _internal_delta_yaw_window();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL VacNetShot::mutable_delta_yaw_window()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_yaw_window)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_delta_yaw_window();
}
inline const ::google::protobuf::RepeatedField<float>&
VacNetShot::_internal_delta_yaw_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delta_yaw_window_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
VacNetShot::_internal_mutable_delta_yaw_window() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.delta_yaw_window_;
}

// repeated float delta_pitch_window = 7;
inline int VacNetShot::_internal_delta_pitch_window_size() const {
  return _internal_delta_pitch_window().size();
}
inline int VacNetShot::delta_pitch_window_size() const {
  return _internal_delta_pitch_window_size();
}
inline void VacNetShot::clear_delta_pitch_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delta_pitch_window_.Clear();
}
inline float VacNetShot::delta_pitch_window(int index) const {
  // @@protoc_insertion_point(field_get:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window().Get(index);
}
inline void VacNetShot::set_delta_pitch_window(int index, float value) {
  _internal_mutable_delta_pitch_window()->Set(index, value);
  // @@protoc_insertion_point(field_set:VacNetShot.delta_pitch_window)
}
inline void VacNetShot::add_delta_pitch_window(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_delta_pitch_window()->Add(value);
  // @@protoc_insertion_point(field_add:VacNetShot.delta_pitch_window)
}
inline const ::google::protobuf::RepeatedField<float>& VacNetShot::delta_pitch_window() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:VacNetShot.delta_pitch_window)
  return _internal_delta_pitch_window();
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL VacNetShot::mutable_delta_pitch_window()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:VacNetShot.delta_pitch_window)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_delta_pitch_window();
}
inline const ::google::protobuf::RepeatedField<float>&
VacNetShot::_internal_delta_pitch_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delta_pitch_window_;
}
inline ::google::protobuf::RepeatedField<float>* PROTOBUF_NONNULL
VacNetShot::_internal_mutable_delta_pitch_window() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.delta_pitch_window_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::EHitGroup> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::EHitGroup>() {
  return ::EHitGroup_descriptor();
}
template <>
struct is_proto_enum<::ETeam> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::ETeam>() {
  return ::ETeam_descriptor();
}
template <>
struct is_proto_enum<::EWeaponType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::EWeaponType>() {
  return ::EWeaponType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // fatdemo_2eproto_2epb_2eh
